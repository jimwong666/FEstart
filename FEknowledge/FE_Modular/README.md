
* [基本用法](#基本用法)
* [绘制形状](#绘制形状)
  * [绘制矩形](#-绘制矩形)
  * [绘制路径](#-绘制路径)
    * [移点命令](#--移点命令)
    * [直线命令](#--直线命令)
    * [圆弧命令](#--圆弧命令)
    * [椭圆命令](#--椭圆命令)
    * [贝塞尔曲线命令](#--贝塞尔曲线命令)
    * [矩形命令](#--矩形命令)
  * [Path2D对象](#-Path2D对象)
* [样式与颜色](#样式与颜色)
  * [颜色](#-颜色)
  * [整体透明度](#-整体透明度)
  * [线型](#-线型)
  * [渐变](#-渐变)
  * [图案](#-图案)
  * [阴影](#-阴影)
* [绘制文本](#绘制文本)
* [使用图片](#使用图片)
* [变形](#变形)
  * [移动](#-移动)
  * [旋转](#-旋转)
  * [缩放](#-缩放)
  * [变形](#-变形)
* [合成与裁剪](#合成与裁剪)
  * [合成](#-合成)
  * [裁剪](#-裁剪)
* [动画](#动画)
* [像素操作](#像素操作)
* [与SVG对比一下](#与SVG对比一下)

# 前言

我们在平常开发时，在代码中经常会碰到：
```js
  require('xxxxxx');
```
或者是:
```js
  import xxx form 'xxx';
```

大家都知道这是引入模块，是前端的模块化。但同样都是引入模块，它们为什么不一样呢？什么地方用 require 而什么地方有用 import 呢？

那么今天我们一起来探讨学习一下！

# 前端模块化

在JavaScript发展**初期**。

为了实现简单的页面交互逻辑，js代码寥寥数语即可；但是如今CPU、浏览器性能都得到了极大的提升，很多的页面逻辑处理都迁移到了客户端，这就造成了前端代码的逐渐庞大和复杂。

而当js项目的复杂度变大后，开发者就需要组织（复用、依赖等等）这些复杂的代码。遗憾的是当时的js并没有像Java的package这样的模块化，可是就连css都有@import...

所以js开发者急需模拟出类似的功能，来隔离、组织复杂的Javascript代码，即我们称为前端模块化。

<hr/>

> 在我们刚接触前端的时候，经常会听说 前端模块化，或许很多人都可以说出几个熟悉的名词，比如：

* **立即执行函数** （IIFE [Immediately Invoked Function Expression]）
* **Common.js**
* **AMD**
* **CMD**
* **ES6 Module**

现在就让我们从十年前开始，来看看模块化是怎么一步步完善的：

# IIFE

IIFE 即 立即执行函数，其实平常很多人都用过 IIFE，也知道它是怎么回事，但这里我们仍旧来认识解释一下它：


最开始，我们对于模块区分的概念，可能是从文件的区分开始的，在一个简易的项目中，编程的习惯是通过一个 HTML 文件加上若干个 JavaScript 文件来区分不同的模块，就像这样：

<p align="center">
    <img src="https://github.com/jimwong666/FEstart/blob/master/FEknowledge/FE_Modular/images/iife.jpg" alt="IIFE">
</p>

