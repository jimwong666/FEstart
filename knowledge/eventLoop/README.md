# event loop (事件循环)

### event loop 是什么

在 W3C文档 中我们可以找到关于它的描述：

> 客户端必须使用本章节中所描述的事件循环，来协调事件，用户交互，脚本，呈现，网络等等。事件循环有两种：用于浏览上下文的事件循环和用于 worker 的事件循环。

##### 假如有这样一个例子：

```js
  // 实在找不到好例子了
  let a = {
	  b: 1
  };

  console.log(a.b); // 1

  a.b = 2;
```

*现在打印出来肯定是 **1**，那怎么样在不改变顺序的情况下依然立即打印出 **2** 呢？？？*


##### 其实就是利用event loop，像下面这样就行了：

```js
  let a = {
	  b: 1
  };

  settimeout(function(){
	  console.log(a.b); // 2
  }, 0);

  a.b = 2;
```

> 这就是event loop，上述例子最直观的感受就是**它能改变js的执行顺序**。（注意:本篇文章里没做特殊说明的地方，我们说得都是浏览器端运行的js，而非nodeJs）

<hr/>

### event loop 为什么出现

我们都知道浏览器里面JS是JS引擎处理的。

浏览器本身是多进程的，比如：浏览器本身是个进程、浏览器GPU也是个进程、cherome的扩展程序会增加进程、每增加一个标签页也会增加一个**浏览器内核进程**（如图）。


<p align="center">
<img src="https://user-images.githubusercontent.com/20440496/42146675-c35e6bdc-7dfb-11e8-920b-2c626c9845f5.png" alt="浏览器">
<p>图1</p>
</p>

其中浏览器内核进程中的 **JS引擎线程** 就是处理 JS 的。
而且有一个很重要的信息就是：浏览器的 **js引擎** 是单线程的！

**回到一开始的问题，event loop 为什么会出现？**
###### 这样就好解释多了，既然是单线程，那么代码执行的时候总得有先有后吧~ 所以event loop的执行顺序规则不就应运而生了嘛！

> 思考:为什么**JS引擎**要设计成单线程呢？
> 1. 首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。
> 2. 其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。
> 3. 如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。
> 
> 这样就导致了 JS引擎 的单线程特性。



