## 动态规划

> 动态规划在寻找有很多重叠子问题的情况的最佳解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被储存，从简单的问题直到整个问题都被解决。因此，动态规划储存递迴时的结果，因而不会在解决同样的问题时花费时间。
> 动态规划只能应用于有最佳子结构的问题。最佳子结构的意思是局部最佳解能决定全域最佳解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

##### 例1：斐波那契数列（简单）
> 斐波那契数列: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...
> 它遵循这样的规律： 当前值等于前两个值得和。
> 那么第 n 个值是多少？【f(n) = f(n-1)+f(n-2)】

1. 递归（反例）

```js
    function fib(n) {
        if(n < 2){
            return n;
        } else {
            return fib(n-1) + fib(n-2)
        }
    }

    fib(100);
    // 等到天荒地老~然后卡了
```

2. 动态规划(正解)

```js
    function fib(n){
        // 缓存一下
        let results = [];

        for(let i = 0; i < n; i++){
            if(i < 2){
                results[i] = i;
            } else {
                results[i] = results[i-1] + results[i-2];
            }
        }

        return results[n-1];
    }; 
```

1. leetdode [62.不同路径](https://leetcode-cn.com/problems/unique-paths/ "leetcode - 动态规划") <br/>

